// This file will be auto-generated by Wails
// For now, we'll create mock bindings that match the expected API

export interface Collection {
  id: number;
  name: string;
  description: string;
  created_at: string;
  updated_at: string;
}

export interface Folder {
  id: number;
  name: string;
  collection_id: number;
  parent_folder_id?: number;
  created_at: string;
}

export interface Request {
  id: number;
  name: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
  url: string;
  headers: string;
  body: string;
  collection_id?: number;
  folder_id?: number;
  created_at: string;
  updated_at: string;
}

export interface Environment {
  id: number;
  name: string;
  variables: string;
  is_active: boolean;
  created_at: string;
}

export interface RequestHistory {
  id: number;
  request_id: number;
  response_status: number;
  response_time: number;
  response_body: string;
  response_headers: string;
  executed_at: string;
}

export interface APIResponse {
  status: number;
  statusText: string;
  headers: string;
  body: string;
  responseTime: number;
  contentType: string;
}

// Mock implementation - this will be replaced by Wails generated bindings
class APIClientService {
  // Collections
  async CreateCollection(name: string, description: string): Promise<Collection> {
    const collection = {
      id: Date.now(),
      name,
      description,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    
    // Store in localStorage for persistence
    const collections = this.getStoredCollections();
    collections.push(collection);
    localStorage.setItem('goman_collections', JSON.stringify(collections));
    
    return collection;
  }

  async GetCollections(): Promise<Collection[]> {
    return this.getStoredCollections();
  }

  async GetCollection(id: number): Promise<Collection | null> {
    const collections = this.getStoredCollections();
    return collections.find(c => c.id === id) || null;
  }

  async UpdateCollection(id: number, name: string, description: string): Promise<Collection> {
    const collections = this.getStoredCollections();
    const index = collections.findIndex(c => c.id === id);
    if (index !== -1) {
      collections[index] = {
        ...collections[index],
        name,
        description,
        updated_at: new Date().toISOString(),
      };
      localStorage.setItem('goman_collections', JSON.stringify(collections));
      return collections[index];
    }
    throw new Error('Collection not found');
  }

  async DeleteCollection(id: number): Promise<void> {
    const collections = this.getStoredCollections();
    const filtered = collections.filter(c => c.id !== id);
    localStorage.setItem('goman_collections', JSON.stringify(filtered));
  }

  // Folders
  async CreateFolder(name: string, collectionId: number, parentFolderId?: number): Promise<Folder> {
    const folder = {
      id: Date.now(),
      name,
      collection_id: collectionId,
      parent_folder_id: parentFolderId,
      created_at: new Date().toISOString(),
    };
    
    const folders = this.getStoredFolders();
    folders.push(folder);
    localStorage.setItem('goman_folders', JSON.stringify(folders));
    
    return folder;
  }

  async GetFolders(): Promise<Folder[]> {
    return this.getStoredFolders();
  }

  async UpdateFolder(id: number, name: string, collectionId: number, parentFolderId?: number): Promise<Folder> {
    const folders = this.getStoredFolders();
    const index = folders.findIndex(f => f.id === id);
    if (index !== -1) {
      folders[index] = {
        ...folders[index],
        name,
        collection_id: collectionId,
        parent_folder_id: parentFolderId,
      };
      localStorage.setItem('goman_folders', JSON.stringify(folders));
      return folders[index];
    }
    throw new Error('Folder not found');
  }

  async DeleteFolder(id: number): Promise<void> {
    const folders = this.getStoredFolders();
    const filtered = folders.filter(f => f.id !== id);
    localStorage.setItem('goman_folders', JSON.stringify(filtered));
  }

  // Requests
  async CreateRequest(
    name: string,
    method: string,
    url: string,
    headers: string,
    body: string,
    collectionId?: number,
    folderId?: number
  ): Promise<Request> {
    const request: Request = {
      id: Date.now(),
      name,
      method: method as Request['method'],
      url,
      headers,
      body,
      collection_id: collectionId,
      folder_id: folderId,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    
    const requests = this.getStoredRequests();
    requests.push(request);
    localStorage.setItem('goman_requests', JSON.stringify(requests));
    
    return request;
  }

  async GetRequests(): Promise<Request[]> {
    return this.getStoredRequests();
  }

  async UpdateRequest(
    id: number,
    name: string,
    method: string,
    url: string,
    headers: string,
    body: string,
    collectionId?: number,
    folderId?: number
  ): Promise<Request> {
    const requests = this.getStoredRequests();
    const index = requests.findIndex(r => r.id === id);
    if (index !== -1) {
      requests[index] = {
        ...requests[index],
        name,
        method: method as Request['method'],
        url,
        headers,
        body,
        collection_id: collectionId,
        folder_id: folderId,
        updated_at: new Date().toISOString(),
      };
      localStorage.setItem('goman_requests', JSON.stringify(requests));
      return requests[index];
    }
    throw new Error('Request not found');
  }

  async DeleteRequest(id: number): Promise<void> {
    const requests = this.getStoredRequests();
    const filtered = requests.filter(r => r.id !== id);
    localStorage.setItem('goman_requests', JSON.stringify(filtered));
  }

  // Environments
  async CreateEnvironment(name: string, variables: string): Promise<Environment> {
    const environment = {
      id: Date.now(),
      name,
      variables,
      is_active: false,
      created_at: new Date().toISOString(),
    };
    
    const environments = this.getStoredEnvironments();
    environments.push(environment);
    localStorage.setItem('goman_environments', JSON.stringify(environments));
    
    return environment;
  }

  async GetEnvironments(): Promise<Environment[]> {
    return this.getStoredEnvironments();
  }

  async UpdateEnvironment(id: number, name: string, variables: string, isActive: boolean): Promise<Environment> {
    const environments = this.getStoredEnvironments();
    
    // If setting this as active, deactivate others
    if (isActive) {
      environments.forEach(env => {
        env.is_active = env.id === id;
      });
    }
    
    const index = environments.findIndex(e => e.id === id);
    if (index !== -1) {
      environments[index] = {
        ...environments[index],
        name,
        variables,
        is_active: isActive,
      };
      localStorage.setItem('goman_environments', JSON.stringify(environments));
      return environments[index];
    }
    throw new Error('Environment not found');
  }

  async DeleteEnvironment(id: number): Promise<void> {
    const environments = this.getStoredEnvironments();
    const filtered = environments.filter(e => e.id !== id);
    localStorage.setItem('goman_environments', JSON.stringify(filtered));
  }

  async GetActiveEnvironment(): Promise<Environment | null> {
    const environments = this.getStoredEnvironments();
    return environments.find(env => env.is_active) || null;
  }

  // Request execution
  async ExecuteRequest(method: string, url: string, headers: string, body: string): Promise<APIResponse> {
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 500));
    
    // Mock response based on the URL
    const mockResponses = [
      {
        status: 200,
        statusText: 'OK',
        headers: JSON.stringify({
          'content-type': 'application/json',
          'content-length': '156',
          'server': 'nginx/1.18.0',
          'date': new Date().toUTCString(),
        }),
        body: JSON.stringify({
          message: 'Success',
          data: {
            id: 123,
            name: 'Sample Response',
            timestamp: new Date().toISOString(),
            method: method,
            url: url,
          },
          meta: {
            total: 1,
            page: 1,
          }
        }, null, 2),
        responseTime: Math.floor(Math.random() * 1000 + 100),
        contentType: 'application/json',
      },
      {
        status: 404,
        statusText: 'Not Found',
        headers: JSON.stringify({
          'content-type': 'application/json',
          'server': 'nginx/1.18.0',
          'date': new Date().toUTCString(),
        }),
        body: JSON.stringify({
          error: 'Resource not found',
          code: 404,
          message: 'The requested resource could not be found',
        }, null, 2),
        responseTime: Math.floor(Math.random() * 500 + 50),
        contentType: 'application/json',
      }
    ];
    
    // Return random response for demo
    return mockResponses[Math.floor(Math.random() * mockResponses.length)];
  }

  // Helper methods for localStorage
  private getStoredCollections(): Collection[] {
    const stored = localStorage.getItem('goman_collections');
    return stored ? JSON.parse(stored) : [];
  }

  private getStoredFolders(): Folder[] {
    const stored = localStorage.getItem('goman_folders');
    return stored ? JSON.parse(stored) : [];
  }

  private getStoredRequests(): Request[] {
    const stored = localStorage.getItem('goman_requests');
    return stored ? JSON.parse(stored) : [];
  }

  private getStoredEnvironments(): Environment[] {
    const stored = localStorage.getItem('goman_environments');
    return stored ? JSON.parse(stored) : [];
  }
}

// Export singleton instance
export const APIClientServiceInstance = new APIClientService();